from discord_slash import SlashCommand
from discord_slash.utils.manage_commands import create_option
import os
import asyncio
import pixivpy3
import discord 
#import keep_alive
import webserver
import picture
import requests
from googletrans import Translator
import help
import conversation
from datetime import datetime,timezone,timedelta
update = "é è¨ˆæ›´æ–°ï¼šè®“æ©Ÿå™¨äººè—‰ç”±AIèˆ‡ä½¿ç”¨è€…å°è©±"


token = os.environ['discord_token']
_REFRESH_TOKEN = os.environ['pixiv_refresh_token']
api_key = os.environ['weather_key']
base_url = "http://api.openweathermap.org/data/2.5/weather?"
translator = Translator()
headers = {'Referer': 'https://www.pixiv.net/'}
verify = False
bot = discord.Client(intents=discord.Intents.all())
slash = SlashCommand(bot , sync_commands=True)
guild_ids = [912688935363305484]

client = discord.Client()                     #clienté€£çµDiscord

@client.event                                 #èª¿ç”¨ event å‡½å¼åº«
async def on_ready():  
  stat='è¶…ç•°åŸŸå…¬ä¸»é€£çµâ˜†Re:Dive'
  print(f'ç›®å‰ç™»å…¥èº«ä»½ï¼š{client.user}')
  await client.change_presence(status=discord.Status.online, activity=discord.Game(stat))
print('æ©Ÿå™¨äººå•Ÿå‹•')


@slash.slash(name="ping",description="just test", guild_ids=guild_ids)
async def _ping(message,*,i):
  await message.send(f"{i}! ({bot.latency*1000}ms)")

@client.event
async def on_voice_state_update(member, before, after):
  await asyncio.sleep(1)
  name=member.name.split('#',2)
  try:
    channelID=after.channel.id
    DV=open('channelID/DV_ChannelID','r')
    temp=eval(DV.read())
    DV.close()
    print('ä½¿ç”¨è€…ç›®å‰é »é“:',after.channel.name)
    if 'çš„èªéŸ³é »é“' not in str(after.channel.name):
      for i in temp:
        if int(i) == int(channelID):
          print("trigger DVchannel",channelID)
          channel = client.get_channel(int(i))
          channelID = await member.guild.create_voice_channel(name=f'{name[0]}çš„èªéŸ³é »é“',overwrites=None, category=channel.category, reason=None)
          await member.move_to(channelID)
          f = open('channelID/V_ChannelID','r')
          temp=eval(f.read())
          f.close()
          temp.append(str(channelID.id))
          f = open('channelID/V_ChannelID','w')
          f.write(str(temp))
          f.close()
          print(name[0],'å‰µå»ºæˆåŠŸ')
          return
    else:
      raise ValueError("ERROR")
  except:
    print("trigger cancel channel")
    path = 'channelID/V_ChannelID'
    f = open(path,'r')
    temp=eval(f.read())
    f.close()
    for i in temp:
      if int(i) == int(before.channel.id):
        channel = client.get_channel(before.channel.id)
        members = channel.members
        if len(members) == 0:
          await channel.delete()
          temp.remove(str(i))
          t = open(path, 'w')
          t.write(str(temp))
          t.close() 
          print(f'{channel}åˆªé™¤æˆåŠŸ')
  return

@client.event                                 #èª¿ç”¨ event å‡½å¼åº«
async def on_message(message):                #ç•¶æœ‰è¨Šæ¯æ™‚
  dt1 = datetime.utcnow().replace(tzinfo=timezone.utc)
  dt2 = dt1.astimezone(timezone(timedelta(hours=8))) # è½‰æ›å°ç£æ™‚å€
  ticks = dt2.strftime("%H:%M:%S")
    
  if message.author == client.user:         #æ’é™¤è‡ªå·±çš„è¨Šæ¯
    return

  name = message.author.mention
  try:
    conv=str(message.author)+'æ–¼'+str(ticks)+'åœ¨'+str(message.guild.name)+'çš„'+str(message.channel)+'èªª:'+str(message.content)
  except:
    conv=str(message.author)+'æ–¼'+str(ticks)+'åœ¨'+str(message.channel)+'èªª:'+str(message.content)
  conversation.write_log(conv)

  if message.content.startswith('#'):       #æŒ‡ä»¤åˆ¤æ–·
    tmp = message.content.split("#",2)    #åˆ‡å…©åˆ€è¨Šæ¯
    if len(tmp) == 1:   #å¦‚æœåˆ†å‰²å¾Œä¸²åˆ—é•·åº¦åªæœ‰1
      await message.reply("æˆ‘ä¸çŸ¥é“æ‚¨åœ¨èªªä»€éº¼èª’...\nå¯ä»¥è«‹æ‚¨å†èªªä¸€æ¬¡å—?")
      await message.channel.send('https://i.imgur.com/V1P5kV2.jpg')
      return
    else:
      tmp = message.content.split(" ",2)

      if len(tmp[0]) > 1:
        await message.reply("æŒ‡ä»¤éŒ¯èª¤...\nå¯ä»¥è«‹æ‚¨å†èªªä¸€æ¬¡å—?")
        await message.channel.send('https://i.imgur.com/V1P5kV2.jpg')
        return

      if 'ping' == tmp[1]:
        await message.reply(f'å»¶é²:{round(client.latency * 1000)}')
        return
        
      if 'help' == tmp[1]:   #æŒ‡ä»¤å¹«åŠ©
        embed=discord.Embed(title="æ©Ÿå™¨äººæŒ‡ä»¤ä½¿ç”¨èªªæ˜", description="è®“æ‚¨äº†è§£å¦‚ä½•æ´»ç”¨æˆ‘çš„åŠ›é‡!", color=0xd98d91)
        file = discord.File("introduction.jpg", filename="introduction.jpg")
        embed = help.help(embed)
        await message.channel.send(file=file,embed=embed)
        return

      if 'æ›´æ”¹' == tmp[1]:
        game = discord.Game(tmp[2])
        await client.change_presence(status=discord.Status.online, activity=game)
        await message.channel.send(f'å·²è¨­å®šæˆ‘çš„ç‹€æ…‹ç‚º{tmp[2]}å›‰!')
        return

      if 'update' == tmp[1]:
        await message.channel.send(update)
        return

      if 'trans' == tmp[1]:
        try:
          tmp = message.content.split("# trans ",2)
          output = translator.translate(tmp[1], dest='zh-tw').text
          await message.channel.send(f'ç¿»è­¯ï¼š{output}')
          return
        except:
          await message.reply("æŒ‡ä»¤éŒ¯èª¤...\nå¯ä»¥è«‹æ‚¨å†èªªä¸€æ¬¡å—?\næŒ‡ä»¤ç”¨æ³•ç‚ºï¼š# trans [æ¬²ç¿»è­¯çš„æ–‡å­—æˆ–å¥å­]")
          await message.channel.send('https://i.imgur.com/V1P5kV2.jpg')
          return

      if 'weather' == tmp[1]:
        try:
          tmp = message.content.split("# weather ",2)
          city_name = tmp[1]
          complete_url = base_url + "appid=" + api_key + "&q=" + city_name
          response = requests.get(complete_url)
          x = response.json()
          if x["cod"] != "404": 
            async with message.channel.typing():
              y = x["main"]
              current_temperature = y["temp"]
              current_temperature_celsiuis = str(round(current_temperature - 273.15))
              current_pressure = y["pressure"]
              current_humidity = y["humidity"]
              z = x["weather"]
              city_name = translator.translate(tmp[1], dest='zh-tw').text
              embed = discord.Embed(title=f"é€™æ˜¯åœ¨ {city_name} çš„å¤©æ°£", color=0xd98d91)
              weather_description = translator.translate(z[0]["description"], dest='zh-tw').text
              embed.add_field(name="å¤©æ°£ç‹€æ³", value=f"**{weather_description}**", inline=False)
              embed.add_field(name="æº«åº¦ï¼ˆÂ°Cï¼‰", value=f"**{current_temperature_celsiuis}Â°C**", inline=False)
              embed.add_field(name="æ¿•åº¦(%)", value=f"**{current_humidity}%**", inline=False)
              embed.add_field(name="å¤§æ°£å£“åŠ›(hPa)", value=f"**{current_pressure}hPa**", inline=False)
              embed.set_thumbnail(url="https://i.ibb.co/CMrsxdX/weather.png")
              embed.set_footer(text=f"è¦æ±‚è‡ªï¼š{message.author.name}")
              await message.channel.send(embed=embed) 
              return
          else:
            await message.channel.send("æˆ‘æ‰¾ä¸åˆ°é€™å€‹åŸå¸‚å–”ğŸ˜¨")
            return
        except:
          await message.reply("æŒ‡ä»¤éŒ¯èª¤...\nå¯ä»¥è«‹æ‚¨å†èªªä¸€æ¬¡å—?")
          await message.channel.send('https://i.imgur.com/V1P5kV2.jpg')
          return

      if 'random' == tmp[1] or 'picture' == tmp[1]:
        tmp = message.content.split(" ",3)
        try:
          picture.locate = 1
          if 'random' == tmp[1]:
            picture.pic_random(tmp[1])
          if 'picture' == tmp[1]:
            picture.pic_random(tmp[2])
          embed=discord.Embed(color=0xd98d91)
          if picture.locate == 1:
            if 'http' in picture.pic1:
              embed.set_image(url=picture.pic1)
              await message.channel.send(embed=embed)
            elif 'http' in picture.pic2:
              embed.set_author(name=picture.pic1)
              embed.set_image(url=picture.pic2)
              await message.channel.send(embed=embed)
            elif 'http' in picture.pic3:
              embed.set_author(name=picture.pic1)
              embed.set_image(url=picture.pic2)
              await message.channel.send(embed=embed)
              embed.set_image(url=picture.pic3)
              await message.channel.send(embed=embed)
          if picture.locate == 0:
            await message.reply('æ‚¨æŒ‡å®šçš„é€™ä½è€å©†ï¼Œæˆ‘ä¸èªè­˜å¥¹èª’...ğŸ˜°')
            await message.channel.send('https://i.imgur.com/nbs4CXK.jpg')
          return

        except:
          await message.reply("æŒ‡ä»¤éŒ¯èª¤...\nå¯ä»¥è«‹æ‚¨å†èªªä¸€æ¬¡å—?")
          await message.channel.send('https://i.imgur.com/V1P5kV2.jpg')
          return

      if 'pixiv' == tmp[1]:
        aapi = pixivpy3.AppPixivAPI()
        async with message.channel.typing():
          tmp = message.content.split(" ",4)
          search = tmp[2]

          try:
            if int(tmp[3]) > 30:
              await message.reply('æœ€å¤šåªèƒ½æŸ¥è©¢30å¼µåœ–ç‰‡å–”')
              return
            elif int(tmp[3]) > 1:
              tmp = int(tmp[3]) - 1
            elif int(tmp[3]) == 1:
              tmp = 0
          except:
            tmp = 0
          
          try:
            aapi.auth(refresh_token=_REFRESH_TOKEN)
            json_result = aapi.search_illust(search,search_target='partial_match_for_tags')
            illust = json_result.illusts[tmp]
          except:
            await message.reply('pixivä¸Šæ²’æœ‰é—œæ–¼é€™å€‹é—œéµå­—çš„åœ–ç‰‡å–”')
          
          url = illust.image_urls['large']
          url = url.split('https://i.pximg.net',2)
          #url = 'https://i.pixiv.cat' + url[1]
          url = 'https://pixiv.runrab.workers.dev' + url[1]
          embed=discord.Embed(color=0xd98d91)
          embed.set_image(url=url)
          embed.set_author(name=illust.title)
          await message.channel.send(embed=embed)
          return
      
      if 'create' == tmp[1]:
        voice = message.guild.voice_channels
        tmp = message.content.split(" ",4)
        c = open('channelID/T_ChannelID', 'r')
        temp = eval(c.read())
        if str(message.channel.id) in str(temp):
          print('ç›¸ç¬¦')
        else:
          await message.reply('é€™å€‹é »é“ç„¡æ³•ä½¿ç”¨æ­¤æŒ‡ä»¤å–”')
          return
        c.close()
        for i in voice[:len(voice)]:
          if str(i) == str(tmp[2]):
            await message.channel.send('æ­¤é »é“å·²å­˜åœ¨')
            return
        try:
          print(tmp[3])
        except:
          tmp.append('0')
        await message.guild.create_voice_channel(name=tmp[2],overwrites=None, category=message.channel.category, reason=None,user_limit=tmp[3])
        await message.reply('é »é“å‰µå»ºæˆåŠŸ!')
        voice = message.guild.voice_channels
        for i in voice:
          if str(tmp[2]) == str(i):
            f = open('channelID/V_ChannelID', 'r')
            temp = eval(f.read())
            #print(f'é•·åº¦ç‚º{len(temp)}ï¼Œå…§å®¹ç‚º{temp}')
            temp.append(str(i.id))
            f.close()
            t = open('channelID/V_ChannelID', 'w')
            #print(temp)
            t.write(str(temp))
            t.close()
        return
        
      if 'vcset' == tmp[1]:
        if message.author.guild_permissions.manage_channels or str(message.author.id) == '540134212217602050':
          try:
            tmp = message.content.split(" ",4)
          except:
            tmp = message.content.split(" ",3)
            tmp[3] = 0
          c = open('channelID/T_ChannelID', 'r')
          temp = eval(c.read())
          c.close()
          if str(tmp[2]) in str(temp):
            await message.reply('æ­¤é »é“å·²ç™»è¨˜')
            return
          channel = client.get_channel(int(tmp[2]))
          #print(channel)
          if channel != None:
            f = open('channelID/T_ChannelID', 'w')
            temp.append(str(tmp[2]))
            f.write(str(temp))
            f.close()
            await message.reply(f'å·²è¨­å®š{channel.name}ç‚ºå‹•æ…‹èªéŸ³ç”¢ç”Ÿé »é“')
            return
          else:
            await message.reply('æœªæ‰¾åˆ°æ­¤é »é“')
            return
        else:
          await message.reply('æ‚¨æ²’æœ‰æ¬Šé™åŸ·è¡Œæ­¤æ“ä½œ')
          return
        
      if 'vcdel' == tmp[1]:
        if message.author.guild_permissions.manage_channels or str(message.author.id) == '540134212217602050':
          try:
            tmp = message.content.split(" ",3)
          except:
            await message.reply("æŒ‡ä»¤éŒ¯èª¤...\nè«‹è¼¸å…¥é »é“id")
            await message.channel.send('https://i.imgur.com/V1P5kV2.jpg')
            return
          c = open('channelID/T_ChannelID', 'r')
          temp = eval(c.read())
          c.close()
          if str(tmp[2]) in str(temp):
            channel = client.get_channel(int(tmp[2]))
            #print(channel)
            if channel != None:
              f = open('channelID/T_ChannelID', 'w')
              temp.remove(str(tmp[2]))
              f.write(str(temp))
              f.close()
              await message.reply(f'åˆªé™¤{channel.name}æˆåŠŸ')
              return
            else:
              await message.reply('æœªæ‰¾åˆ°æ­¤é »é“')
              return
        else:
          await message.reply('æ‚¨æ²’æœ‰æ¬Šé™åŸ·è¡Œæ­¤æ“ä½œ')
          return

      if 'send' == tmp[1]:
        if str(message.author.id) == '540134212217602050':
          tmp = message.content.split("# send ",)
          await message.delete()
          await message.channel.send(tmp[1])
          return
        else:
          await message.reply(f'<@!540134212217602050>ï¼Œ<@{str(message.author.id)}>åœ¨äº‚ç©æŒ‡ä»¤')
          return

      if 'vcconfig' == tmp[1]:
        if str(message.author.id) == '540134212217602050':
          c = open('channelID/T_ChannelID', 'r')
          f = open('channelID/V_ChannelID', 'r')
          temp1 = eval(c.read())
          temp2 = eval(f.read())
          c.close()
          f.close()
          config = ""
          for i in temp1:
            channel = client.get_channel(int(i))
            config = str(config) + str(channel) + '\n'
          config = config + 'ä»¥ä¸Šç‚ºæ–‡å­—é »é“\n\n'
          for i in temp2:
            channel = client.get_channel(int(i))
            config =str(config) + str(channel) + '\n'
          config = str(config) + 'ä»¥ä¸Šç‚ºèªéŸ³é »é“\n'
          await message.reply(config)
          return
          
        else:
          await message.reply(f'<@!540134212217602050>ï¼Œ<@{str(message.author.id)}>åœ¨äº‚ç©æŒ‡ä»¤')
          return
        
      if 'public' == tmp[1]:
        if str(message.author.id) == '540134212217602050':
          tmp = message.content.split("# public ",)
          c = open('channelID/T_ChannelID', 'r')
          temp = eval(c.read())
          c.close()
          progress = 0
          for i in temp:
            progress = progress + 1
            channel = client.get_channel(int(i))
            await channel.send(str(tmp[1]))
            await message.channel.send(f"å·²åœ¨{channel}ç™¼é€å…¬å‘Šï¼Œé€²åº¦ç‚º{progress}/{len(temp)}")
          return
        else:
          await message.reply(f'<@!540134212217602050>ï¼Œ<@{str(message.author.id)}>åœ¨äº‚ç©æŒ‡ä»¤')
          return
      
      if 'PSend' == tmp[1]:
        if str(message.author.id) == '540134212217602050':
          tmp = message.content.split(" ")
          channel = client.get_channel(int(tmp[2]))
          print(channel.name)
          await channel.send(str(tmp[3]))
          return
        else:
          await message.reply(f'<@!540134212217602050>ï¼Œ<@{str(message.author.id)}>åœ¨äº‚ç©æŒ‡ä»¤')
          return

      if 'check' == tmp[1]:
        activeservers = client.guilds
        for i in activeservers:
          await message.channel.send(i)
        print(activeservers)
        return
      
      if 'join' == tmp[1]:
        channel=message.author.voice.channel
        await channel.connect()
        return
      
      if 'leave' == tmp[1]:
        await channel.voice_client.disconnect()
        return


      else:
        await message.reply("æŒ‡ä»¤éŒ¯èª¤...\nå¯ä»¥è«‹æ‚¨å†èªªä¸€æ¬¡å—?\nè¼¸å…¥ # help ç²å¾—æŒ‡ä»¤èªªæ˜")
        await message.channel.send('https://i.imgur.com/V1P5kV2.jpg')
        return

  if message.content == 'å—¨':
    await message.reply(f'æ—©å®‰å•Š,{name}ç‹å­å…ˆç”Ÿ',mention_author=True)
    return

  if message.content == 'æ—©å®‰':
    await message.reply(f'æ—©å®‰å•Š,{name}ç‹å­å…ˆç”Ÿ',mention_author=True)
    return

  if '909796683418832956' in message.content:  #æ¨™è¨˜æ©Ÿå™¨äºº
    await message.reply(conversation.tag(name))
    return
  
  if 'å¥½' in message.content:
    keyword=['å¥½è€¶','ã€Œå¥½ã€','é‚„å¥½','æˆ‘å¥½','å¥½èª’','å¸¶å¥½','å°±å¥½','å¥½äº†æ²’','å¥½é•·']
    for i in keyword:
      if i in message.content:
        return
    if (len(message.content) > 7 ):
      return
    if 'ä½ å¥½' == message.content or 'å¦³å¥½' == message.content or 'æ‚¨å¥½' == message.content:
      await message.reply(f'æ‚¨å¥½å•Š,{name}ç‹å­å…ˆç”Ÿâ¤ï¸',mention_author=True)
      return
    await message.reply('çŸ¥é“å°±å¥½ğŸ˜Œ', mention_author=True)
    return
        
  if 'rick' in message.content:
    await message.channel.send('æœ‰äººæåˆ°rickrollå—ğŸ˜€?')
    await message.channel.send('<a:yellow_guy:910197305540481056>')
    return
  
  else:
    conv=str(message.content)
    conv=conversation.gif(conv)
    if conv == False:
      return
    else:
      await message.channel.send(conv)
      return
        
@client.event
async def on_typing(channel, user, when):
  #if '432188735531122700' in str(user.id):
    #message=await channel.send('è«‹ä½ æƒ³å¥½å†ç™¼è¨€')
    #await asyncio.sleep(0.5)
    #await message.delete()
  return

webserver.keep()
client.run(token)